use proc_macro2;
use quote::{ToTokens, TokenStreamExt};
use syn;
use tl_lang_syn as tlsn;

use ::constructor_def::ConstructorDefNamespace;
use ::function_def::FunctionDefNamespace;
use ::type_def::TypeDefNamespace;


#[derive(Debug, Eq, PartialEq)]
pub struct Schema {
    pub layer: u32,
    pub type_def_ns: TypeDefNamespace,
    pub constructor_def_ns: ConstructorDefNamespace,
    pub function_def_ns: FunctionDefNamespace,
}

impl Schema {
    pub fn from_tl_file(tl_file: &tlsn::File) -> Self {
        let tlsn::File { ref items } = *tl_file;

        fn get_layer(items: &[tlsn::Item]) -> Option<u32> {
            for item in items {
                if let tlsn::Item::Layer(ref layer) = *item {
                    return Some(layer.layer);
                }
            }

            None
        }

        Schema {
            layer: get_layer(items).unwrap_or(0),
            type_def_ns: TypeDefNamespace::from_tl_items(items),
            constructor_def_ns: ConstructorDefNamespace::from_tl_items(items),
            function_def_ns: FunctionDefNamespace::from_tl_items(items),
        }
    }

    pub fn to_syn_mod(&self) -> syn::ItemMod {
        syn::parse2(self.into_token_stream()).unwrap()
    }
}

impl ToTokens for Schema {
    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {
        let Schema { layer, ref type_def_ns, ref constructor_def_ns, ref function_def_ns } = *self;

        let doc = proc_macro2::Literal::string(&format!(
            "/// Autogenerated TL-schema for Telegram API. Currently layer {}.",
            layer,
        ));

        tokens.append_all(quote! {
            #[doc = #doc]
            #[allow(non_camel_case_types)]
            pub mod schema {
                pub const LAYER: u32 = #layer;

                #type_def_ns
                #constructor_def_ns
                #function_def_ns
            }
        });
    }
}
